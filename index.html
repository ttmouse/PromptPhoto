<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PromptPhoto 提示词生成器</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+SC:wght@400;600&family=Playfair+Display:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
      :root { --bg:#faf9fb; --panel:#ffffff; --text:#3a3a40; --muted:#7a7f86; --accent:#ff8aa0; --accent-2:#ff6f91; --accent-soft: rgba(255,111,145,.12); --accent-hover: rgba(255,111,145,.16); --border:#eceff3; --chip-bg:#fff3f5; --chip-hover:#ffe9ee; --shadow-soft: 0 8px 20px rgba(58,58,64,.06); --sidebar-width: 280px; }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin:0; background:var(--bg); color:var(--text); font-family: Inter, "Noto Sans SC", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial; line-height: 1.6; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility; padding-left: var(--sidebar-width); }
      .wrap { max-width: 1200px; margin: 0 auto; padding: 28px 28px 150px; }
      .header { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:26px; }
      .title { font-size: 22px; font-weight: 700; letter-spacing: .15px; }
      html.lang-en .title { font-family: "Playfair Display", ui-serif, Georgia, "Times New Roman", serif; font-weight:600; }
      .controls { display:flex; gap:10px; flex-wrap:wrap; }
      button { background:var(--accent); color:#3a0d17; border:none; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; transition:transform .08s ease; box-shadow: none; }
      button:active { transform: scale(.98); }
      .btn-cta { padding:12px 18px; font-weight:700; border-radius:14px; }
      .btn-secondary { background:var(--panel); color:var(--text); border:1px solid var(--border); }
      .grid { display:grid; grid-template-columns: minmax(0, 1.35fr) minmax(0, 1fr); gap:22px; align-items:start; }
      @media (max-width: 1200px) {
        .grid { grid-template-columns: 1fr; }
        .left-panel, .right-sticky { position:relative; height:auto; max-height:none; }
        .right-sticky { top:auto; }
      }
      .card { background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:20px; box-shadow: var(--shadow-soft); }
      .left-panel { height: calc(100vh - 220px); display:flex; flex-direction:column; }
      .dimension-header { flex-shrink:0; display:flex; justify-content:space-between; align-items:center; padding-bottom:12px; margin-bottom:12px; border-bottom:1px solid var(--border); }
      .dimension-header h3 { margin:0; }
      .dimension-body { flex:1; overflow-y:auto; padding-right:4px; }
      .description-editor { margin-bottom:16px; display:flex; flex-direction:column; gap:6px; }
      .description-editor label { font-size:13px; font-weight:600; color:var(--muted); }
      .description-editor textarea { width:100%; min-height:110px; border:1px solid var(--border); border-radius:12px; padding:10px 12px; font-family: inherit; font-size:13px; resize:vertical; background:var(--panel); color:var(--text); box-shadow:none; }
      .description-editor textarea:focus { outline:2px solid var(--accent-soft); border-color:var(--accent-2); }
      .description-hint { margin:0; font-size:12px; color:var(--muted); }
      .dimension-tools { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
      .dimension-set-select { border:1px solid var(--border); border-radius:10px; padding:6px 12px; background:var(--panel); color:var(--text); font-size:13px; min-width:150px; }
      .right-sticky { position: sticky; top: 96px; max-height: calc(100vh - 220px); height: calc(100vh - 220px); display:flex; flex-direction:column; overflow:hidden; }
      .right-sticky .output { flex:1; overflow:auto; }
      .card h3 { margin:0 0 12px 0; font-size:16px; font-weight:600; color:var(--accent-2); }
      .group { margin-bottom:18px; padding:12px; border-radius:14px; transition: background .2s ease; position:relative; }
      .dimension-groups { display:flex; flex-direction:column; gap:18px; }
      .group.collapsed,
      .group.group-disabled { padding-bottom:10px; margin-bottom:14px; }
      .group-content { padding-top:8px; }
      .group.group-disabled { background:#f4f5f8; }
      .group.group-locked { background:#f8f8fb; border-color:#e3e6ef; }
      .group.group-locked .group-title { color:#4d515c; }
      .group.group-disabled .group-content { display:none; }
      .group-title-row { display:flex; align-items:center; gap:10px; margin-bottom:8px; flex-wrap:wrap; position:relative; padding-left:28px; width:100%; }
      .group.collapsed > :not(.group-title-row) { display:none; }
      .group-title { font-size:14px; font-weight:600; color:var(--text); letter-spacing:.1px; flex:1; min-width:0; }
      .group.collapsed .group-title-row,
      .group.group-disabled .group-title-row { margin-bottom:0; }
      .group-actions { margin-left:auto; display:flex; align-items:center; gap:6px; flex-wrap:nowrap; }
      .options { display:flex; flex-wrap:wrap; gap:8px; }
      .option { background:#ffffff; color:var(--text); border:1px solid var(--border); border-radius:999px; padding:7px 12px; cursor:pointer; font-weight:400; letter-spacing:.1px; transition: background .2s ease, border-color .2s ease, color .2s ease; box-shadow:none; }
      .option:hover { background:var(--chip-hover); }
      .option.active { border-color: var(--accent); background: var(--accent-soft); color:#3a0d17; }
      .option:focus-visible { outline:2px solid var(--accent); outline-offset:2px; }
      .option.disabled { opacity:.5; pointer-events:none; }
      .option.single-option { display:inline-flex; align-items:center; gap:6px; }
      .option.locked-view { border-color:#d9dce5; background:#f5f6fb; color:#5f6571; }
      .option .caret { display:inline-flex; align-items:center; justify-content:center; width:12px; height:12px; margin-left:6px; }
      .option .caret svg { width:12px; height:12px; stroke: var(--muted); fill:none; }
      .option.active .caret svg { stroke: var(--accent-2); }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .toggle { display:flex; align-items:center; gap:8px; padding:6px 6px; background:transparent; border:0; border-radius:10px; color:var(--muted); }
      .toggle input[type="checkbox"] { accent-color: var(--accent); width:16px; height:16px; }
      .toggle input:checked + label { color: var(--accent-2); }
      .group-disabled .group-title { color:#b0b4ba; }
      .group-disabled .option { background:#f8f8fb; border-color:#e3e5ec; color:#a5aab4; }
      .output { width:100%; min-height:260px; white-space:pre-wrap; background:#ffffff; border:1px solid var(--border); border-radius:12px; padding:14px; color:var(--text); font-size:14px; font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      .scroll-soft { scrollbar-width: thin; scrollbar-color: rgba(122,127,134,.25) transparent; }
      .scroll-soft::-webkit-scrollbar { width:6px; }
      .scroll-soft::-webkit-scrollbar-track { background: transparent; }
      .scroll-soft::-webkit-scrollbar-thumb { background: rgba(122,127,134,.3); border-radius:999px; border:1px solid rgba(255,255,255,.4); }
      .scroll-soft:hover::-webkit-scrollbar-thumb { background: rgba(122,127,134,.45); }
      .custom-section { border-top:1px solid var(--border); margin-top:20px; padding-top:16px; }
      .custom-section-header { display:flex; justify-content:flex-start; align-items:center; margin-bottom:10px; }
      .custom-form { display:flex; flex-direction:column; gap:8px; margin-bottom:16px; }
      .custom-form .row { display:flex; gap:8px; flex-wrap:wrap; }
      .custom-form input, .custom-form textarea { width:100%; border:1px solid var(--border); border-radius:10px; padding:8px 10px; font-family:inherit; font-size:13px; color:var(--text); background:#fff; }
      .custom-form textarea { min-height:80px; resize:vertical; }
      .custom-form-actions { display:flex; gap:8px; }
      .custom-hint { font-size:12px; color:var(--muted); margin:0; }
      .custom-status { font-size:12px; color:var(--accent-2); margin:0; min-height:16px; }
      .custom-dimensions-list { display:flex; flex-direction:column; gap:14px; }
      .custom-dimension-card { border:1px solid var(--border); border-radius:14px; padding:12px; }
      .custom-dimension-header { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:10px; }
      .custom-dimension-name { font-weight:600; font-size:13px; color:var(--muted); }
      .custom-actions { display:flex; gap:6px; }
      .custom-text-btn { background:transparent; border:none; color:var(--accent-2); font-size:12px; cursor:pointer; padding:4px 6px; border-radius:8px; }
      .custom-text-btn:hover { background:var(--accent-soft); }
      .custom-add-btn { background:#ff4d4f; color:#fff; border:none; border-radius:14px; padding:8px 16px; font-weight:600; cursor:pointer; box-shadow:var(--shadow-soft); transition:transform .08s ease; }
      .custom-add-btn:active { transform:scale(.98); }
      .custom-modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:120; }
      .custom-modal-overlay.hidden { display:none; }
      .custom-modal { background:var(--panel); border-radius:20px; padding:24px; width:min(420px, 90vw); box-shadow:var(--shadow-soft); border:1px solid var(--border); display:flex; flex-direction:column; gap:14px; }
      .custom-modal-header { display:flex; justify-content:space-between; align-items:center; }
      .custom-modal-header h3 { margin:0; font-size:16px; color:var(--accent-2); }
      .custom-modal-close { background:transparent; border:none; font-size:18px; line-height:1; cursor:pointer; color:var(--muted); padding:4px; border-radius:8px; }
      .custom-modal-close:hover { color:var(--accent-2); background:var(--accent-soft); }
      body.modal-open { overflow:hidden; }
      .hidden { display:none !important; }
      
      .pill { display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; background:var(--chip-bg); border:1px solid var(--border); color:var(--muted); }
      .footer { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:16px; }
      .small { font-size:12px; color:var(--muted); }
      .lang-toggle { display:flex; gap:6px; }
      .lang-btn { background:var(--chip-bg); color:var(--text); border:1px solid var(--border); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:400; box-shadow:none; }
      .lang-btn.active { border-color: var(--accent); color:#3a0d17; background: var(--accent-soft); }
      .lang-btn:focus-visible { outline:2px solid var(--accent); outline-offset:2px; }
      .btn-cta { padding:12px 18px; font-weight:700; border-radius:14px; box-shadow: 0 6px 14px rgba(255,111,145,.12); }
      .sub-title { font-size:12px; font-weight:500; color:var(--muted); }
      .sub-title-row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; position:relative; padding-left:24px; }
      .sub-actions { margin-left:auto; display:flex; align-items:center; gap:4px; }
      .sub-title-row .lock-btn { margin-left:0; }
      .sub-title-row .visibility-btn { padding:4px; border-radius:50%; }
      .sub-disabled .sub-title { color:#c6cad3; }
      .sub-title-row.sub-locked .sub-title { color:#4c4f59; font-weight:600; }
      .options-block.sub-disabled,
      .options.sub-disabled { display:none; }
      .options.sub-locked .option,
      .options-block.sub-locked .option { background:#f8f8fb; color:#5c606a; border-color:#d9dce5; }
      .options-block { margin-bottom:8px; }
      .options-block.collapsed { display:none; }
      select { width:100%; appearance:none; -webkit-appearance:none; -moz-appearance:none; background-color:#fff; border:1px solid var(--border); color:var(--text); border-radius:10px; padding:8px 34px 8px 10px; line-height:1.4; font-size:14px; background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='none' stroke='%237a7f86' stroke-width='2' d='M7 10l5 5 5-5'/></svg>"); background-repeat:no-repeat; background-position: calc(100% - 10px) 50%; background-size:12px; }
      .lock-btn { background:transparent; border:none; color:var(--muted); padding:4px; border-radius:50%; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; width:auto; }
      .lock-btn svg { width:16px; height:16px; stroke: currentColor; fill:none; }
      .lock-btn:hover { color:var(--accent-2); }
      .lock-btn.locked { color:var(--accent-2); }
      .lock-btn:focus-visible { outline:2px solid var(--accent-soft); outline-offset:2px; }
      .option-lock-btn { background:transparent; border:none; color:#9499a7; padding:4px; border-radius:50%; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; }
      .option-lock-btn:hover { color:var(--accent-2); }
      .option-lock-btn:focus-visible { outline:2px solid var(--accent-soft); outline-offset:2px; }
      .option-lock-btn svg { width:14px; height:14px; stroke:currentColor; fill:none; }
      .locked-chip { display:flex; align-items:center; gap:6px; }
      .locked-chip .option { margin:0; }
      .group.group-disabled .lock-btn,
      .group.group-disabled .collapse-btn,
      .group.group-disabled .visibility-btn { color:#c0c4cf; }
      .collapse-btn { background:transparent; border:none; padding:4px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; color:var(--muted); position:absolute; left:0; top:50%; transform: translateY(-50%); }
      .collapse-btn svg { width:16px; height:16px; stroke:currentColor; fill:none; transition: transform .2s ease; }
      .collapse-btn:focus-visible { outline:2px solid var(--accent-soft); outline-offset:2px; }
      .collapse-btn.collapsed svg { transform: rotate(-90deg); }
      .visibility-btn { background:transparent; border:none; color:var(--muted); padding:4px; border-radius:50%; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; }
      .visibility-btn svg { width:16px; height:16px; stroke:currentColor; fill:none; }
      .visibility-btn:focus-visible { outline:2px solid var(--accent-soft); outline-offset:2px; }
      .global-bar { position: fixed; bottom: 20px; left: calc(var(--sidebar-width) + (100vw - var(--sidebar-width))/2); transform: translateX(-50%); width: max-content; max-width: calc(100vw - var(--sidebar-width) - 40px); background: rgba(255,255,255,.92); border:1px solid var(--border); box-shadow: 0 12px 30px rgba(0,0,0,.08); border-radius:18px; padding:10px 18px; display:inline-flex; justify-content:center; gap:10px; z-index:50; backdrop-filter: blur(8px); }
      .action-btn { display:inline-flex; align-items:center; gap:8px; border:1px solid var(--border); background:var(--panel); color:var(--text); border-radius:999px; padding:9px 16px; font-size:13px; font-weight:600; box-shadow: inset 0 1px 0 rgba(255,255,255,.6); transition: all .15s ease; }
      .action-btn:hover { border-color: var(--accent-2); color: var(--accent-2); }
      .action-btn.copied { border-color: var(--accent-2); color: var(--accent-2); background:var(--accent-soft); }
      .action-btn.copy-error { border-color:#f26b6b; color:#aa1c1c; background:rgba(242,107,107,.15); }
      .action-btn.accent { background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%); color:#fff; border:none; box-shadow:none; }
      .action-btn.accent:hover { filter: brightness(1.05); }
      .action-btn.danger { border-color:#f26b6b; color:#aa1c1c; background:#fff6f6; }
      .action-btn.danger:hover { background:#ffecec; }
      .btn-icon { display:inline-flex; align-items:center; justify-content:center; }
      .action-btn svg { width:16px; height:16px; stroke:currentColor; fill:none; }
      .action-btn.accent svg { stroke:#fff; }
      .v-subtitle { font-size:12px; color:var(--muted); margin:6px 0; }
      .v-subitems { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:6px; }
      .popover { position:absolute; z-index:1000; background:#fff; border:1px solid var(--border); border-radius:10px; box-shadow: var(--shadow-soft); padding:6px; }
      .popover ul { list-style:none; margin:0; padding:0; max-height:220px; overflow:auto; }
      .popover li { padding:6px 8px; border-radius:8px; cursor:pointer; }
      .popover li:hover { background:var(--chip-hover); }
      .preset-sidebar { position:fixed; left:0; top:0; bottom:0; width:var(--sidebar-width); padding:20px 18px 20px 18px; border-right:1px solid var(--border); background:var(--panel); box-shadow: 4px 0 20px rgba(58,58,64,.06); display:flex; flex-direction:column; gap:14px; z-index:90; }
      .preset-sidebar-header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
      .preset-sidebar-actions { display:flex; align-items:center; gap:6px; }
      .preset-sidebar-title { font-size:15px; font-weight:600; color:var(--accent-2); }
      .preset-count-label { font-size:12px; color:var(--muted); margin-left:6px; }
      .preset-sidebar button.sidebar-close { display:none; }
      .preset-search { position:relative; }
      .preset-search input { width:100%; border:1px solid var(--border); border-radius:12px; padding:8px 12px 8px 32px; font-size:13px; }
      .preset-search svg { position:absolute; left:10px; top:50%; transform:translateY(-50%); width:14px; height:14px; stroke:var(--muted); }
      .preset-tag-filter { display:flex; flex-wrap:wrap; gap:6px; }
      .preset-tag-chip { border:1px solid var(--border); background:#fff; color:var(--muted); border-radius:999px; padding:4px 10px; font-size:11px; cursor:pointer; }
      .preset-tag-chip.active { border-color:var(--accent-2); color:var(--accent-2); background:var(--accent-soft); }
      .preset-tag-empty { font-size:11px; color:var(--muted); }
      .preset-card-list { flex:1; overflow:auto; display:flex; flex-direction:column; gap:8px; padding-right:4px; }
      .preset-empty { font-size:12px; color:var(--muted); text-align:center; padding:20px 0; }
      .preset-card { border:1px solid var(--border); border-radius:14px; padding:8px 12px; display:flex; gap:10px; background:#fff; cursor:pointer; position:relative; transition:border-color .15s ease, box-shadow .15s ease; }
      .preset-card.active { border-color:var(--accent-2); box-shadow:0 8px 18px rgba(255,111,145,0.15); }
      .preset-card:hover { border-color:var(--accent-2); }
      .preset-card-thumb { width:46px; height:46px; border-radius:12px; background:linear-gradient(135deg,#ffe0ec,#ffeef5); flex-shrink:0; overflow:hidden; display:flex; align-items:center; justify-content:center; font-weight:700; color:#c84a6a; }
      .preset-card-thumb img { width:100%; height:100%; object-fit:cover; }
      .preset-card-content { flex:1; display:flex; flex-direction:column; gap:4px; min-width:0; }
      .preset-card-header { display:flex; justify-content:space-between; align-items:center; gap:6px; }
      .preset-card-name { font-size:12px; font-weight:600; color:var(--text); margin:0; flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:flex; align-items:center; gap:4px; }
      .preset-card-count-text { font-size:11px; color:var(--muted); font-weight:500; }
      .preset-tag-list { display:flex; flex-wrap:wrap; gap:4px; }
      .preset-tag { font-size:10px; padding:2px 6px; border-radius:999px; background:#f4f5f8; color:#5d616b; }
      .preset-card-actions { position:absolute; top:6px; right:6px; display:flex; gap:4px; opacity:0; pointer-events:none; transition:opacity .15s ease; }
      .preset-card:hover .preset-card-actions { opacity:1; pointer-events:auto; }
      .preset-card-actions button { width:28px; height:28px; border-radius:10px; border:1px solid rgba(58,58,64,.08); background:rgba(255,255,255,.95); display:flex; align-items:center; justify-content:center; color:var(--muted); padding:0; backdrop-filter: blur(4px); }
      .preset-card-actions button:hover { border-color:var(--accent-2); color:var(--accent-2); }
      .preset-card-actions svg { width:16px; height:16px; stroke:currentColor; fill:none; }
      .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
      @media (max-width: 768px) {
        body { padding-left:0; }
        .preset-sidebar { position:relative; width:100%; height:auto; top:0; bottom:auto; border-right:none; box-shadow:none; }
        .wrap { padding:20px; }
        .global-bar { left:50%; width:auto; max-width: calc(100vw - 40px); }
      }
      .preset-modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:100; }
      .preset-modal-overlay.hidden { display:none; }
      .preset-modal { background:var(--panel); border-radius:20px; padding:24px; width:min(320px, 90vw); display:flex; flex-direction:column; gap:14px; box-shadow:var(--shadow-soft); border:1px solid var(--border); }
      .preset-modal h3 { margin:0; font-size:16px; color:var(--accent-2); text-align:center; }
      .preset-modal input { border:1px solid var(--border); border-radius:12px; padding:10px 12px; font-size:13px; }
      .preset-modal .modal-actions { display:flex; gap:10px; }
      .preset-modal .modal-actions button { flex:1; }
      .preset-modal .action-btn { width:100%; justify-content:center; }
      .preset-modal-delete { border:none; background:none; color:#c5464f; font-size:12px; font-weight:600; align-self:center; padding:0; cursor:pointer; opacity:.8; transition:opacity .15s ease; display:inline-flex; align-items:center; }
      .preset-modal-delete:hover { opacity:1; text-decoration:underline; }
      .thumbnail-drop-zone { border:1px dashed var(--border); border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:6px; transition:border-color .2s ease, background .2s ease, box-shadow .2s ease; }
      .thumbnail-drop-zone:focus-within { border-color:var(--accent-2); box-shadow:0 0 0 2px var(--accent-soft); }
      .thumbnail-drop-zone.dragover { border-color:var(--accent-2); background:var(--accent-soft); }
      .thumbnail-drop-zone input { border:none; padding:0; background:transparent; font-size:13px; width:100%; }
      .thumbnail-drop-zone input:focus { outline:none; }
      .thumbnail-drop-hint { margin:0; font-size:12px; color:var(--muted); }
      .thumbnail-drop-status { margin:0; font-size:12px; color:var(--muted); min-height:16px; }
      .thumbnail-drop-status.success { color:#2e7d32; }
      .thumbnail-drop-status.error { color:#c62828; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <div class="title" id="appTitle">PromptPhoto 提示词生成器</div>
        <div class="controls">
          <div class="lang-toggle">
            <button id="lang-zh" class="lang-btn active">中文</button>
            <button id="lang-en" class="lang-btn">EN</button>
          </div>
        </div>
      </div>

      <div class="grid">
        <div class="card left-panel">
          <div class="description-editor">
            <label for="descriptionInput" id="descriptionLabel">整体描述</label>
            <textarea id="descriptionInput" placeholder="在此编辑整体描述…"></textarea>
            <p class="description-hint" id="descriptionHint">文本会同步到 JSON description 字段。</p>
          </div>
                    <div class="row dimension-header">
            <h3 id="dimensionHeading">维度选择</h3>
            <div class="dimension-tools">
              <select id="dimensionSetSelect" class="dimension-set-select"></select>
              <button id="modeToggle" class="btn-secondary" title="切换视图模式">下拉模式</button>
            </div>
          </div>
          <div class="dimension-body scroll-soft">
            <div id="dimensionGroupContainer" class="dimension-groups"></div>
            <div class="custom-section">
            <div class="custom-section-header">
              <button id="customAddTrigger" class="custom-add-btn" type="button">添加维度</button>
            </div>
            <div id="customDimensionsContainer" class="custom-dimensions-list"></div>
          </div>
        </div>
        </div>
        <div class="card right-sticky">
          <h3 id="outputHeading">JSON 输出</h3>
          <div id="promptOutput" class="output scroll-soft"></div>
        </div>
      </div>
      <div id="presetSidebar" class="preset-sidebar">
        <div class="preset-sidebar-header">
          <div class="preset-sidebar-title"><span id="presetSidebarTitleText">配置缓存</span><span id="presetCountLabel" class="preset-count-label">(0)</span></div>
          <div class="preset-sidebar-actions"></div>
        </div>
        <div class="preset-search">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="presetSearchInput" type="search" placeholder="搜索预设…">
        </div>
        <div class="preset-tag-filter" id="presetTagFilter"></div>
        <div id="presetCardList" class="preset-card-list scroll-soft"></div>
      </div>

      <div id="presetModalOverlay" class="preset-modal-overlay hidden" role="dialog" aria-modal="true">
        <div class="preset-modal">
          <h3 id="presetModalTitle">保存配置</h3>
          <input id="presetModalInput" type="text" placeholder="配置名称"/>
          <input id="presetTagsInput" type="text" placeholder="标签（逗号分隔）"/>
          <div id="thumbnailDropZone" class="thumbnail-drop-zone">
            <input id="presetThumbnailInput" type="text" placeholder="缩略图 URL（可选）"/>
            <p id="thumbnailDropHint" class="thumbnail-drop-hint">可粘贴图片链接，或拖入图片自动生成 Data URL。</p>
            <p id="thumbnailDropStatus" class="thumbnail-drop-status"></p>
          </div>
          <div class="modal-actions">
            <button id="presetModalCancel" class="action-btn" type="button">取消</button>
            <button id="presetModalSave" class="action-btn accent" type="button">保存</button>
          </div>
          <button id="presetModalDelete" class="preset-modal-delete" type="button">删除预设</button>
        </div>
      </div>

      <div id="customModalOverlay" class="custom-modal-overlay hidden" role="dialog" aria-modal="true">
        <div class="custom-modal">
          <div class="custom-modal-header">
            <h3 id="customModalTitle">添加维度</h3>
            <button id="customModalClose" class="custom-modal-close" type="button" aria-label="关闭">×</button>
          </div>
          <div class="custom-form" id="customForm">
            <div class="row">
              <input id="customNameZh" type="text" placeholder="维度名称（中文）"/>
              <input id="customNameEn" type="text" placeholder="Dimension name (EN)"/>
            </div>
            <textarea id="customOptionsInput" placeholder="每行：柔和光线 | Soft lighting"></textarea>
            <p class="custom-hint" id="customOptionsHint">使用“中文 | English”格式，一行一个选项。</p>
            <div class="custom-form-actions">
              <button id="customCancelBtn" class="btn-secondary" type="button">取消</button>
              <button id="customSaveBtn" class="btn-cta" type="button">添加维度</button>
            </div>
            <p class="custom-status" id="customFormStatus"></p>
          </div>
        </div>
      </div>

      <div class="global-bar">
        <button id="randomAll" class="action-btn accent">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="16 3 21 3 21 8"></polyline>
              <line x1="4" y1="20" x2="9" y2="15"></line>
              <line x1="4" y1="4" x2="15" y2="15"></line>
              <polyline points="16 16 21 16 21 21"></polyline>
              <line x1="15" y1="9" x2="21" y2="15"></line>
            </svg>
          </span>
          <span id="randomLabel">随机</span>
        </button>
        <button id="copyPrompt" class="action-btn">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
            </svg>
          </span>
          <span id="copyLabel">复制</span>
        </button>
        <button id="savedPanelToggle" class="action-btn" type="button">
          <span class="btn-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 4h16l1 4H3z"></path>
              <path d="M6 12v7h12v-7"></path>
              <path d="M10 12v4"></path>
              <path d="M14 12v4"></path>
            </svg>
          </span>
          <span id="saveLabel">保存</span>
        </button>
      </div>
    </div>

    <script type="module">
      const CONFIG_URL = './config/prompt-config.json';
      function deepClone(obj) {
        if (obj === null || obj === undefined) return obj;
        try {
          return structuredClone(obj);
        } catch (err) {
          return JSON.parse(JSON.stringify(obj));
        }
      }
      async function loadPromptConfig() {
        try {
          const response = await fetch(CONFIG_URL, { cache: 'no-store' });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.json();
        } catch (error) {
          console.error('Failed to load prompt config', error);
          return {};
        }
      }
      const STORAGE_KEY = 'promptPhotoSelections_v1';
      function loadPersistedState() {
        if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') return null;
        try {
          const raw = window.localStorage.getItem(STORAGE_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch (e) {
          return null;
        }
      }
      function saveToStorage(data) {
        if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') return;
        try {
          window.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {}
      }
      const savedData = loadPersistedState();
      const promptConfig = await loadPromptConfig();
      const defaults = deepClone(promptConfig.defaults) || {};

      const descriptions = {
        en: (promptConfig.descriptions && promptConfig.descriptions.en) || defaults.description || '',
        zh: (promptConfig.descriptions && promptConfig.descriptions.zh) || ''
      };
      if (savedData?.descriptions) {
        descriptions.en = typeof savedData.descriptions.en === 'string' ? savedData.descriptions.en : descriptions.en;
        descriptions.zh = typeof savedData.descriptions.zh === 'string' ? savedData.descriptions.zh : descriptions.zh;
      }

      const options = deepClone(promptConfig.options) || {};
      const uiLabels = deepClone(promptConfig.uiLabels) || { groups: {}, subs: {} };
      const uiText = deepClone(promptConfig.uiText) || {};

      let customDimensions = Array.isArray(savedData?.customDimensions) ? savedData.customDimensions : [];
      let activeDimensionSetKey = savedData?.dimensionSetKey || null;
      const normalizedSaved = Array.isArray(savedData?.savedConfigs) ? savedData.savedConfigs : [];
      let savedConfigs = normalizeSavedConfigs(normalizedSaved);
      let activeSavedConfigId = savedData?.activeSavedConfigId || null;
      if (activeSavedConfigId && !savedConfigs.some(cfg => cfg.id === activeSavedConfigId)) {
        activeSavedConfigId = null;
      }
      let editingCustomId = null;
      let editingPresetId = null;
      let presetSearchTerm = '';
      const activePresetTags = new Set();
      let copyFeedbackTimer = null;
      const current = { lang: savedData?.currentLang || 'zh' };
      function updateLangClass() {
        document.documentElement.lang = current.lang;
        document.documentElement.classList.toggle('lang-en', current.lang === 'en');
      }
      updateLangClass();
      function getActiveDimensionSet() {
        return dimensionSetMap[activeDimensionSetKey] || normalizedDimensionSets[0];
      }
      function renderDimensionSetSelect() {
        const select = els.dimensionSetSelect;
        if (!select) return;
        select.innerHTML = '';
        normalizedDimensionSets.forEach(set => {
          const option = document.createElement('option');
          option.value = set.key;
          const label = (set.label && (set.label[current.lang] || set.label.zh)) || set.key;
          option.textContent = label;
          if (set.key === activeDimensionSetKey) option.selected = true;
          select.appendChild(option);
        });
        const hasMultipleSets = normalizedDimensionSets.length > 1;
        select.disabled = !hasMultipleSets;
        select.style.display = hasMultipleSets ? '' : 'none';
      }
      let uiMode = savedData?.uiMode || 'dropdown';


      const els = {
        promptOutput: document.getElementById('promptOutput'),
        randomAll: document.getElementById('randomAll'),
        randomLabel: document.getElementById('randomLabel'),
        copyPrompt: document.getElementById('copyPrompt'),
        copyLabel: document.getElementById('copyLabel'),
        descriptionInput: document.getElementById('descriptionInput'),
        descriptionLabel: document.getElementById('descriptionLabel'),
        descriptionHint: document.getElementById('descriptionHint'),
        langZh: document.getElementById('lang-zh'),
        langEn: document.getElementById('lang-en'),
        appTitle: document.getElementById('appTitle'),
        dimensionHeading: document.getElementById('dimensionHeading'),
        dimensionGroupContainer: document.getElementById('dimensionGroupContainer'),
        dimensionSetSelect: document.getElementById('dimensionSetSelect'),
        outputHeading: document.getElementById('outputHeading'),
        customAddTrigger: document.getElementById('customAddTrigger'),
        customNameZh: document.getElementById('customNameZh'),
        customNameEn: document.getElementById('customNameEn'),
        customOptionsInput: document.getElementById('customOptionsInput'),
        customSaveBtn: document.getElementById('customSaveBtn'),
        customCancelBtn: document.getElementById('customCancelBtn'),
        customOptionsHint: document.getElementById('customOptionsHint'),
        customFormStatus: document.getElementById('customFormStatus'),
        customDimensionsContainer: document.getElementById('customDimensionsContainer'),
        presetSidebar: document.getElementById('presetSidebar'),
        presetSidebarTitleText: document.getElementById('presetSidebarTitleText'),
        presetCountLabel: document.getElementById('presetCountLabel'),
        presetSearchInput: document.getElementById('presetSearchInput'),
        presetTagFilter: document.getElementById('presetTagFilter'),
        presetCardList: document.getElementById('presetCardList'),
        savedPanelToggle: document.getElementById('savedPanelToggle'),
        saveLabel: document.getElementById('saveLabel'),
        presetModalOverlay: document.getElementById('presetModalOverlay'),
        presetModalInput: document.getElementById('presetModalInput'),
        presetTagsInput: document.getElementById('presetTagsInput'),
        presetThumbnailInput: document.getElementById('presetThumbnailInput'),
        thumbnailDropZone: document.getElementById('thumbnailDropZone'),
        thumbnailDropHint: document.getElementById('thumbnailDropHint'),
        thumbnailDropStatus: document.getElementById('thumbnailDropStatus'),
        presetModalSave: document.getElementById('presetModalSave'),
        presetModalCancel: document.getElementById('presetModalCancel'),
        presetModalDelete: document.getElementById('presetModalDelete'),
        presetModalTitle: document.getElementById('presetModalTitle'),
        customModalOverlay: document.getElementById('customModalOverlay'),
        customModalClose: document.getElementById('customModalClose'),
        customModalTitle: document.getElementById('customModalTitle'),
        modeToggle: document.getElementById('modeToggle')
      };
      const groupWraps = {};
      const visibleGroups = new Set();
      const visibleDimensions = new Set();
      const eyeIcons = {
        on: '<svg viewBox="0 0 24 24"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7z" stroke-width="2"/><circle cx="12" cy="12" r="3" stroke-width="2"/></svg>',
        off: '<svg viewBox="0 0 24 24"><path d="M1 12s4-7 11-7c2.4 0 4.4.7 6 1.7M23 12s-4 7-11 7c-2.4 0-4.4-.7-6-1.7" stroke-width="2"/><path d="M3 3l18 18" stroke-width="2"/></svg>'
      };
      const lockIcons = {
        unlocked: '<svg viewBox="0 0 24 24"><path d="M7 10V8a5 5 0 0110 0v2" stroke-width="2"/><rect x="5" y="10" width="14" height="10" rx="2" stroke-width="2"/></svg>',
        locked: '<svg viewBox="0 0 24 24"><path d="M12 8a4 4 0 018 0v2" stroke-width="2"/><rect x="5" y="10" width="14" height="10" rx="2" stroke-width="2"/></svg>'
      };
      let thumbnailDropStatusKey = null;
      function setVisibilityButtonState(btn, on) {
        if (!btn) return;
        btn.innerHTML = on ? eyeIcons.on : eyeIcons.off;
        btn.setAttribute('aria-pressed', String(!on));
      }
      function syncDescriptionInputValue() {
        if (!els.descriptionInput) return;
        const value = descriptions[current.lang] || '';
        if (els.descriptionInput.value !== value) {
          els.descriptionInput.value = value;
        }
      }
      syncDescriptionInputValue();
      initThumbnailDropZone();
      function updateCopyLabel() {
        if (!els.copyLabel) return;
        let key = 'copy';
        if (els.copyPrompt?.classList.contains('copy-error')) {
          key = 'copyError';
        } else if (els.copyPrompt?.classList.contains('copied')) {
          key = 'copySuccess';
        }
        els.copyLabel.textContent = uiText[key][current.lang];
      }
      const groupOptionMap = deepClone(promptConfig.groupOptionMap) || {};
      const dimensionLayouts = promptConfig.dimensionLayouts || {};
      const dimensionDefaults = promptConfig.dimensionDefaults || {};
      const dimensionSets = Array.isArray(promptConfig.dimensionSets) ? promptConfig.dimensionSets : [];
      const groupsMeta = Array.isArray(promptConfig.groups) ? promptConfig.groups : Object.keys(groupOptionMap).map(key => ({ key }));
      const groupKeys = groupsMeta.map(g => g.key).filter(Boolean);
      if (!groupKeys.length) {
        Object.keys(groupOptionMap).forEach(key => {
          if (!groupKeys.includes(key)) groupKeys.push(key);
        });
      }
      function normalizeDimensionSetEntry(entry = {}) {
        const groupOrder = Array.isArray(entry.groupOrder) && entry.groupOrder.length ? entry.groupOrder.filter(key => groupKeys.includes(key)) : [...groupKeys];
        const sourceMap = entry.dimensionsByGroup && typeof entry.dimensionsByGroup === 'object' ? entry.dimensionsByGroup : {};
        const dimensionsByGroup = {};
        groupOrder.forEach(groupKey => {
          const baseList = Array.isArray(sourceMap[groupKey]) && sourceMap[groupKey].length ? sourceMap[groupKey] : (groupOptionMap[groupKey] || []);
          dimensionsByGroup[groupKey] = baseList.filter(dimKey => options[dimKey]);
        });
        return {
          key: entry.key || `set_${groupOrder.join('_')}`,
          label: entry.label || {},
          default: !!entry.default,
          groupOrder,
          dimensionsByGroup
        };
      }
      let normalizedDimensionSets = dimensionSets.length ? dimensionSets.map(normalizeDimensionSetEntry) : [normalizeDimensionSetEntry({ key: 'default', default: true })];
      const dimensionSetMap = {};
      normalizedDimensionSets.forEach(set => { dimensionSetMap[set.key] = set; });
      function getDimensionSetByKey(key) {
        if (key && dimensionSetMap[key]) return dimensionSetMap[key];
        return normalizedDimensionSets[0];
      }
      function collectDimensionKeysFromSet(set) {
        if (!set) return [];
        const result = [];
        set.groupOrder.forEach(groupKey => {
          (set.dimensionsByGroup[groupKey] || []).forEach(dimKey => {
            if (!options[dimKey] || result.includes(dimKey)) return;
            result.push(dimKey);
          });
        });
        return result;
      }
      function getDimensionKeysForSetKey(key) {
        const set = getDimensionSetByKey(key);
        if (!set) return Object.keys(options);
        return collectDimensionKeysFromSet(set);
      }
      const preferredSetKey = savedData?.dimensionSetKey && dimensionSetMap[savedData.dimensionSetKey]
        ? savedData.dimensionSetKey
        : (promptConfig.meta?.defaultDimensionSet && dimensionSetMap[promptConfig.meta.defaultDimensionSet]
          ? promptConfig.meta.defaultDimensionSet
          : (normalizedDimensionSets.find(set => set.default)?.key || normalizedDimensionSets[0]?.key));
      activeDimensionSetKey = preferredSetKey;
      renderDimensionSetSelect();

      const subToGroupMap = Object.entries(groupOptionMap).reduce((acc, [groupKey, subKeys]) => {
        subKeys.forEach(subKey => { acc[subKey] = groupKey; });
        return acc;
      }, {});
      function setGroupStateByKey(groupKey, on) {
        const wrap = groupWraps[groupKey];
        if (wrap) wrap.classList.toggle('group-disabled', !on);
      }
      if (current.lang === 'en') {
        els.langEn.classList.add('active');
        els.langZh.classList.remove('active');
      }

      function renderOptions(el, list, currentIdx, key) {
        if (!el) return;
        const items = Array.isArray(list) ? list : [];
        el.innerHTML = '';
        if (!items.length) return;
        const numericIdx = Number(currentIdx);
        const safeIdx = Math.max(0, Math.min(items.length - 1, Number.isFinite(numericIdx) ? numericIdx : 0));
        const currentOption = items[safeIdx] || items[0];
        const currentLabel = currentOption ? (currentOption[current.lang] || currentOption.en || currentOption.value || '') : '';
        const isLocked = !!lockedSub[key];
        const isEnabled = enabledSub[key] !== false;
        const shouldShowAll = uiMode === 'expanded' && !isLocked;
        if (shouldShowAll) {
          items.forEach((v, i) => {
            const b = document.createElement('button');
            b.type = 'button';
            b.className = 'option' + (i === safeIdx ? ' active' : '');
            b.dataset.idx = i;
            b.textContent = v[current.lang] || v.en || v.value || '';
            if (!isEnabled) b.classList.add('disabled');
            el.appendChild(b);
          });
        } else {
          const b = document.createElement('button');
          b.type = 'button';
          b.className = 'option active single-option' + (isLocked ? ' locked-view' : '');
          b.dataset.idx = safeIdx;
          if (!isLocked && uiMode !== 'expanded') {
            b.innerHTML = `${currentLabel} <span class="caret"><svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5" stroke-width="2"/></svg></span>`;
          } else {
            b.textContent = currentLabel;
          }
          if (!isEnabled || isLocked) b.classList.add('disabled');
          if (!isLocked && uiMode !== 'expanded' && isEnabled) {
            b.addEventListener('click', (e) => { if (isEnabled) openChipPopover(e.currentTarget, key); });
          }
          if (!isLocked) {
            el.appendChild(b);
          } else {
            const lockedWrap = document.createElement('div');
            lockedWrap.className = 'locked-chip';
            lockedWrap.appendChild(b);
            const inlineLock = document.createElement('button');
            inlineLock.type = 'button';
            inlineLock.className = 'option-lock-btn';
            inlineLock.innerHTML = lockIcons.unlocked;
            inlineLock.title = current.lang === 'zh' ? '解锁' : 'Unlock';
            inlineLock.setAttribute('aria-label', inlineLock.title);
            inlineLock.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              const hasSubBtn = !!document.querySelector(`.lock-btn[data-sub="${key}"]`);
              if (hasSubBtn) {
                applySubLockState(key, false);
              } else {
                const parentGroup = subToGroupMap[key] || key;
                applyGroupLockState(parentGroup, false);
              }
            });
            lockedWrap.appendChild(inlineLock);
            el.appendChild(lockedWrap);
          }
        }
      }

      function getGroupLabel(groupKey) {
        const labels = uiLabels.groups?.[groupKey];
        return labels?.[current.lang] || labels?.zh || labels?.en || groupKey;
      }
      function getDimensionLabel(dimKey) {
        const labels = uiLabels.subs?.[dimKey];
        return labels?.[current.lang] || labels?.zh || labels?.en || dimKey;
      }
      function rebuildDimensionGroups() {
        const container = els.dimensionGroupContainer;
        if (!container) return;
        container.innerHTML = '';
        Object.keys(groupWraps).forEach(key => delete groupWraps[key]);
        visibleGroups.clear();
        visibleDimensions.clear();
        Object.keys(options).forEach(key => { delete els[key]; });
        const activeSet = getActiveDimensionSet();
        if (!activeSet) return;
        activeSet.groupOrder.forEach(groupKey => {
          const dims = (activeSet.dimensionsByGroup[groupKey] || []).filter(dimKey => options[dimKey]);
          if (!dims.length) return;
          visibleGroups.add(groupKey);
          const groupEl = createGroupElement(groupKey);
          container.appendChild(groupEl);
          groupWraps[groupKey] = groupEl;
          const content = groupEl.querySelector('.group-content');
          dims.forEach(dimKey => {
            visibleDimensions.add(dimKey);
            appendDimensionSection(content, dimKey);
          });
          setGroupStateByKey(groupKey, enabled[groupKey] !== false);
          groupEl.classList.toggle('group-locked', !!locked[groupKey]);
        });
        bindDimensionControls();
      }
      function createGroupElement(groupKey) {
        const wrap = document.createElement('div');
        wrap.className = 'group';
        wrap.id = `group-${groupKey}`;
        const header = document.createElement('div');
        header.className = 'group-title-row';
        const collapseBtn = document.createElement('button');
        collapseBtn.className = 'collapse-btn';
        collapseBtn.dataset.group = groupKey;
        collapseBtn.setAttribute('aria-label', '折叠/展开');
        collapseBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M6 9l6 6 6-6" stroke-width="2"/></svg>';
        header.appendChild(collapseBtn);
        const title = document.createElement('div');
        title.className = 'group-title';
        title.dataset.group = groupKey;
        title.textContent = getGroupLabel(groupKey);
        header.appendChild(title);
        const actions = document.createElement('div');
        actions.className = 'group-actions';
        const visBtn = document.createElement('button');
        visBtn.className = 'visibility-btn';
        visBtn.dataset.group = groupKey;
        visBtn.setAttribute('aria-label', '启用/禁用');
        setVisibilityButtonState(visBtn, enabled[groupKey] !== false);
        actions.appendChild(visBtn);
        const lockBtn = document.createElement('button');
        lockBtn.className = 'lock-btn';
        lockBtn.dataset.group = groupKey;
        lockBtn.innerHTML = lockIcons.unlocked;
        lockBtn.setAttribute('aria-label', '锁定');
        setLockButtonState(lockBtn, locked[groupKey]);
        actions.appendChild(lockBtn);
        header.appendChild(actions);
        wrap.appendChild(header);
        const content = document.createElement('div');
        content.className = 'group-content';
        wrap.appendChild(content);
        const collapsed = collapsedGroups[groupKey];
        if (collapsed) {
          wrap.classList.add('collapsed');
          collapseBtn.classList.add('collapsed');
          collapseBtn.setAttribute('aria-expanded', 'false');
        } else {
          collapseBtn.setAttribute('aria-expanded', 'true');
        }
        return wrap;
      }
      function appendDimensionSection(contentEl, dimKey) {
        const row = document.createElement('div');
        row.className = 'sub-title-row';
        const collapseBtn = document.createElement('button');
        collapseBtn.className = 'collapse-btn sub-collapse';
        collapseBtn.dataset.subTarget = dimKey;
        collapseBtn.setAttribute('aria-label', '折叠/展开选项');
        collapseBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M6 9l6 6 6-6" stroke-width="2"/></svg>';
        row.appendChild(collapseBtn);
        const title = document.createElement('div');
        title.className = 'sub-title';
        title.dataset.sub = dimKey;
        title.textContent = getDimensionLabel(dimKey);
        row.appendChild(title);
        const actions = document.createElement('div');
        actions.className = 'sub-actions';
        const visBtn = document.createElement('button');
        visBtn.className = 'visibility-btn';
        visBtn.dataset.sub = dimKey;
        visBtn.setAttribute('aria-label', '启用/禁用');
        actions.appendChild(visBtn);
        const lockBtn = document.createElement('button');
        lockBtn.className = 'lock-btn';
        lockBtn.dataset.sub = dimKey;
        lockBtn.innerHTML = lockIcons.unlocked;
        lockBtn.setAttribute('aria-label', '锁定');
        actions.appendChild(lockBtn);
        row.appendChild(actions);
        contentEl.appendChild(row);
        const layout = dimensionLayouts[dimKey] === 'inline' ? 'options' : 'options options-block';
        const optionWrap = document.createElement('div');
        optionWrap.className = layout;
        optionWrap.id = dimKey;
        contentEl.appendChild(optionWrap);
        els[dimKey] = optionWrap;
        bindOptionContainer(optionWrap, dimKey);
        const collapsed = collapsedSub[dimKey];
        if (collapsed) {
          optionWrap.classList.add('collapsed');
          collapseBtn.classList.add('collapsed');
          collapseBtn.setAttribute('aria-expanded', 'false');
        } else {
          collapseBtn.setAttribute('aria-expanded', 'true');
        }
        setSubStateByKey(dimKey);
      }
      function bindDimensionControls() {
        document.querySelectorAll('.visibility-btn').forEach(btn => {
          const groupKey = btn.dataset.group;
          const subKey = btn.dataset.sub;
          if (groupKey) setVisibilityButtonState(btn, enabled[groupKey] !== false);
          if (subKey) setVisibilityButtonState(btn, enabledSub[subKey] !== false);
          btn.addEventListener('click', e => {
            e.preventDefault();
            if (groupKey) {
              enabled[groupKey] = !enabled[groupKey];
              setGroupStateByKey(groupKey, enabled[groupKey]);
              setVisibilityButtonState(btn, enabled[groupKey]);
            } else if (subKey) {
              enabledSub[subKey] = !enabledSub[subKey];
              setSubStateByKey(subKey);
              setVisibilityButtonState(btn, enabledSub[subKey]);
            }
            composeAndRender();
          });
        });
        document.querySelectorAll('.collapse-btn').forEach(btn => {
          const groupKey = btn.dataset.group;
          if (!groupKey) return;
          const applyState = collapsed => {
            collapsedGroups[groupKey] = collapsed;
            const wrap = groupWraps[groupKey];
            if (wrap) wrap.classList.toggle('collapsed', collapsed);
            btn.classList.toggle('collapsed', collapsed);
            btn.setAttribute('aria-expanded', String(!collapsed));
          };
          applyState(!!collapsedGroups[groupKey]);
          btn.addEventListener('click', e => {
            e.stopPropagation();
            applyState(!collapsedGroups[groupKey]);
          });
        });
        document.querySelectorAll('.sub-collapse').forEach(btn => {
          const key = btn.dataset.subTarget;
          if (!key) return;
          const optionWrap = document.getElementById(key);
          const applyState = collapsed => {
            collapsedSub[key] = collapsed;
            if (optionWrap) optionWrap.classList.toggle('collapsed', collapsed);
            btn.classList.toggle('collapsed', collapsed);
            btn.setAttribute('aria-expanded', String(!collapsed));
          };
          applyState(!!collapsedSub[key]);
          btn.addEventListener('click', e => {
            e.stopPropagation();
            applyState(!collapsedSub[key]);
          });
        });
        document.querySelectorAll('.lock-btn').forEach(btn => {
          const groupKey = btn.dataset.group;
          const subKey = btn.dataset.sub;
          const initialState = groupKey ? locked[groupKey] : lockedSub[subKey];
          setLockButtonState(btn, initialState);
          btn.addEventListener('click', e => {
            e.preventDefault();
            if (groupKey) {
              applyGroupLockState(groupKey, !locked[groupKey]);
            } else if (subKey) {
              applySubLockState(subKey, !lockedSub[subKey]);
            }
          });
        });
      }
      function setActiveDimensionSet(key, opts = {}) {
        let targetKey = key;
        if (!dimensionSetMap[targetKey]) {
          targetKey = normalizedDimensionSets[0]?.key;
        }
        if (!targetKey) return false;
        if (targetKey === activeDimensionSetKey && !opts.force) {
          if (opts.refresh) rebuildDimensionGroups();
          return false;
        }
        activeDimensionSetKey = targetKey;
        renderDimensionSetSelect();
        rebuildDimensionGroups();
        return true;
      }
      function getVisibleDimensionKeys() {
        const keys = [];
        const set = getActiveDimensionSet();
        if (!set) return keys;
        set.groupOrder.forEach(groupKey => {
          (set.dimensionsByGroup[groupKey] || []).forEach(dimKey => {
            if (!keys.includes(dimKey)) keys.push(dimKey);
          });
        });
        return keys;
      }
      function isGroupVisibleNow(groupKey) {
        return visibleGroups.has(groupKey);
      }
      function isDimensionVisibleNow(dimKey) {
        return visibleDimensions.has(dimKey);
      }

      function renderCustomDimensions() {
        const container = els.customDimensionsContainer;
        if (!container) return;
        container.innerHTML = '';
        Object.keys(els).forEach(key => {
          if (key.startsWith('custom_')) delete els[key];
        });
        if (!customDimensions.length) return;
        customDimensions.forEach(dim => {
          const card = document.createElement('div');
          card.className = 'custom-dimension-card';
          const header = document.createElement('div');
          header.className = 'custom-dimension-header';
          const nameEl = document.createElement('div');
          nameEl.className = 'custom-dimension-name';
          nameEl.textContent = dim.name[current.lang] || dim.name.zh || dim.name.en;
          header.appendChild(nameEl);
          const actions = document.createElement('div');
          actions.className = 'custom-actions';
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'custom-text-btn';
          editBtn.textContent = uiText.customEdit[current.lang];
          editBtn.addEventListener('click', () => startEditingCustomDimension(dim.id));
          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.className = 'custom-text-btn';
          deleteBtn.textContent = uiText.customDelete[current.lang];
          deleteBtn.addEventListener('click', () => deleteCustomDimension(dim.id));
          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          header.appendChild(actions);
          card.appendChild(header);
          const optWrap = document.createElement('div');
          optWrap.className = 'options options-block';
          optWrap.id = dim.key;
          card.appendChild(optWrap);
          container.appendChild(card);
          els[dim.key] = optWrap;
          renderOptions(optWrap, options[dim.key] || [], state[dim.key] || 0, dim.key);
          bindOptionContainer(optWrap, dim.key);
        });
      }

      function getPresetDescriptionSnippet(cfg) {
        const desc = cfg?.snapshot?.descriptions?.[current.lang] || cfg?.snapshot?.descriptions?.zh || '';
        return (desc || '').trim();
      }
      function countPresetDimensions(snapshot = {}) {
        const keys = getSnapshotDimensionKeys(snapshot);
        return Array.from(new Set(keys)).length;
      }
      function getAllPresetTags() {
        const tagSet = new Set();
        savedConfigs.forEach(cfg => {
          (cfg.tags || []).forEach(tag => tagSet.add(tag));
        });
        return Array.from(tagSet).sort((a, b) => a.localeCompare(b, 'zh-Hans'));
      }
      function matchesPresetSearch(cfg) {
        const term = presetSearchTerm.trim().toLowerCase();
        if (!term) return true;
        const haystack = [
          cfg.name,
          getPresetDescriptionSnippet(cfg),
          ...(cfg.tags || [])
        ].join(' ').toLowerCase();
        return haystack.includes(term);
      }
      function matchesPresetTags(cfg) {
        if (!activePresetTags.size) return true;
        const tagSet = new Set((cfg.tags || []).map(tag => tag.toLowerCase()));
        for (const tag of activePresetTags) {
          if (!tagSet.has(tag)) return false;
        }
        return true;
      }
      function renderPresetSidebar() {
        const sidebar = els.presetSidebar;
        const list = els.presetCardList;
        if (!sidebar || !list) return;
        const tagContainer = els.presetTagFilter;
        if (!savedConfigs.length) {
          if (tagContainer) tagContainer.innerHTML = `<span class="preset-tag-empty">${uiText.presetTagEmpty[current.lang]}</span>`;
          list.innerHTML = `<div class="preset-empty">${uiText.presetNoPresets[current.lang]}</div>`;
          if (els.presetCountLabel) els.presetCountLabel.textContent = '(0)';
          return;
        }
        const allTags = getAllPresetTags();
        if (tagContainer) {
          if (!allTags.length) {
            tagContainer.innerHTML = `<span class="preset-tag-empty">${uiText.presetTagEmpty[current.lang]}</span>`;
          } else {
            tagContainer.innerHTML = '';
            allTags.forEach(tag => {
              const chip = document.createElement('button');
              chip.type = 'button';
              chip.className = 'preset-tag-chip' + (activePresetTags.has(tag.toLowerCase()) ? ' active' : '');
              chip.textContent = tag;
              chip.dataset.tag = tag;
              tagContainer.appendChild(chip);
            });
          }
        }
        const filtered = savedConfigs.filter(cfg => matchesPresetSearch(cfg) && matchesPresetTags(cfg));
        if (els.presetCountLabel) {
          els.presetCountLabel.textContent = `(${filtered.length})`;
        }
        list.innerHTML = '';
        if (!filtered.length) {
          list.innerHTML = `<div class="preset-empty">${uiText.presetNoResults[current.lang]}</div>`;
          return;
        }
        filtered.forEach(cfg => {
          const card = document.createElement('div');
          card.className = 'preset-card' + (cfg.id === activeSavedConfigId ? ' active' : '');
          card.dataset.id = cfg.id;
          const thumb = document.createElement('div');
          thumb.className = 'preset-card-thumb';
          if (cfg.thumbnail) {
            const img = document.createElement('img');
            img.src = cfg.thumbnail;
            img.alt = cfg.name;
            thumb.appendChild(img);
          } else {
            thumb.textContent = (cfg.name || 'P').slice(0, 1).toUpperCase();
          }
          const content = document.createElement('div');
          content.className = 'preset-card-content';
          const header = document.createElement('div');
          header.className = 'preset-card-header';
          const title = document.createElement('p');
          title.className = 'preset-card-name';
          const titleText = document.createElement('span');
          titleText.textContent = cfg.name;
          const countText = document.createElement('span');
          countText.className = 'preset-card-count-text';
          countText.textContent = `· ${countPresetDimensions(cfg.snapshot)}`;
          title.appendChild(titleText);
          title.appendChild(countText);
          header.appendChild(title);
          content.appendChild(header);
          const tagList = document.createElement('div');
          tagList.className = 'preset-tag-list';
          (cfg.tags || []).slice(0, 4).forEach(tag => {
            const tagEl = document.createElement('span');
            tagEl.className = 'preset-tag';
            tagEl.textContent = tag;
            tagList.appendChild(tagEl);
          });
          content.appendChild(tagList);
          const actions = document.createElement('div');
          actions.className = 'preset-card-actions';
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 113 3L7 19l-4 1 1-4 12.5-12.5z"></path></svg><span class="sr-only">${uiText.presetEdit[current.lang]}</span>`;
          editBtn.addEventListener('click', (e) => { e.stopPropagation(); openSaveModal(cfg.id); });
          actions.appendChild(editBtn);
          content.appendChild(actions);
          card.appendChild(thumb);
          card.appendChild(content);
          card.addEventListener('click', () => loadSavedConfig(cfg.id));
          list.appendChild(card);
        });
      }
      function openSaveModal(presetId = null) {
        editingPresetId = presetId;
        if (els.presetModalOverlay) els.presetModalOverlay.classList.remove('hidden');
        setThumbnailDropStatus(null);
        let preset = null;
        if (presetId) {
          preset = savedConfigs.find(cfg => cfg.id === presetId) || null;
        }
        if (els.presetModalInput) {
          els.presetModalInput.value = preset?.name || '';
          setTimeout(() => els.presetModalInput?.focus(), 0);
        }
        if (els.presetTagsInput) {
          els.presetTagsInput.value = (preset?.tags || []).join(', ');
        }
        if (els.presetThumbnailInput) {
          els.presetThumbnailInput.value = preset?.thumbnail || '';
        }
        if (els.presetModalDelete) {
          els.presetModalDelete.style.display = preset ? 'inline-flex' : 'none';
        }
      }
      function closeSaveModal() {
        editingPresetId = null;
        if (els.presetModalOverlay) els.presetModalOverlay.classList.add('hidden');
        if (els.presetModalInput) els.presetModalInput.value = '';
        if (els.presetTagsInput) els.presetTagsInput.value = '';
        if (els.presetThumbnailInput) els.presetThumbnailInput.value = '';
        if (els.presetModalDelete) els.presetModalDelete.style.display = 'none';
        setThumbnailDropStatus(null);
      }
      function handlePresetSearchInput(value) {
        presetSearchTerm = value || '';
        renderPresetSidebar();
      }
      function togglePresetTag(tag) {
        if (!tag) return;
        const key = tag.toLowerCase();
        if (activePresetTags.has(key)) {
          activePresetTags.delete(key);
        } else {
          activePresetTags.add(key);
        }
        renderPresetSidebar();
      }

      function setThumbnailDropStatus(key) {
        thumbnailDropStatusKey = key || null;
        const statusEl = els.thumbnailDropStatus;
        if (!statusEl) return;
        statusEl.textContent = '';
        statusEl.classList.remove('success', 'error');
        if (!key) return;
        let text = '';
        if (key === 'success') {
          text = uiText.presetThumbnailDropSuccess?.[current.lang] || '';
        } else if (key === 'error') {
          text = uiText.presetThumbnailDropError?.[current.lang] || '';
        }
        statusEl.textContent = text;
        statusEl.classList.add(key);
      }

      function initThumbnailDropZone() {
        const zone = els.thumbnailDropZone;
        const input = els.presetThumbnailInput;
        if (!zone || !input) return;
        const prevent = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };
        const highlight = (e) => {
          prevent(e);
          zone.classList.add('dragover');
        };
        const unhighlight = (e) => {
          prevent(e);
          if (e.type === 'dragleave' && e.relatedTarget && zone.contains(e.relatedTarget)) return;
          zone.classList.remove('dragover');
        };
        ['dragenter', 'dragover'].forEach(evt => zone.addEventListener(evt, highlight));
        ['dragleave', 'dragend'].forEach(evt => zone.addEventListener(evt, unhighlight));
        zone.addEventListener('click', () => input.focus());
        zone.addEventListener('drop', (e) => {
          prevent(e);
          zone.classList.remove('dragover');
          const file = e.dataTransfer?.files?.[0];
          if (!file) {
            setThumbnailDropStatus('error');
            return;
          }
          const type = (file.type || '').toLowerCase();
          const isImageType = type.startsWith('image/');
          const isImageByExt = /\.(png|jpe?g|gif|webp|bmp|heic|heif|avif)$/i.test(file.name || '');
          if (!isImageType && !isImageByExt) {
            setThumbnailDropStatus('error');
            return;
          }
          const reader = new FileReader();
          reader.onload = (event) => {
            input.value = event.target?.result || '';
            input.dispatchEvent(new Event('input', { bubbles: true }));
            setThumbnailDropStatus('success');
          };
          reader.onerror = () => setThumbnailDropStatus('error');
          reader.readAsDataURL(file);
        });
      }

      function replaceMap(target, fallback, incoming) {
        Object.keys(target).forEach(key => { delete target[key]; });
        if (fallback && typeof fallback === 'object') Object.assign(target, fallback);
        if (incoming && typeof incoming === 'object') Object.assign(target, incoming);
      }
      function getSnapshotDimensionKeys(snapshot) {
        const sanitize = (list = []) => Array.from(new Set(list.filter(key => options[key])));
        if (!snapshot) return sanitize(getDimensionKeysForSetKey(activeDimensionSetKey));
        if (Array.isArray(snapshot.dimensionKeys) && snapshot.dimensionKeys.length) {
          return sanitize(snapshot.dimensionKeys);
        }
        if (snapshot.dimensionSetKey) {
          return sanitize(getDimensionKeysForSetKey(snapshot.dimensionSetKey));
        }
        return sanitize(getDimensionKeysForSetKey(activeDimensionSetKey));
      }
      function applyPresetSnapshot(snapshot) {
        if (!snapshot) return;
        replaceMap(state, defaultState, snapshot.state);
        replaceMap(enabled, defaultEnabled, snapshot.enabled);
        replaceMap(enabledSub, defaultEnabledSub, snapshot.enabledSub);
        replaceMap(locked, defaultLocked, snapshot.locked);
        replaceMap(lockedSub, defaultLockedSub, snapshot.lockedSub);
        const dimensionKeysForSnapshot = getSnapshotDimensionKeys(snapshot);
        const dimensionKeySet = new Set(dimensionKeysForSnapshot);
        Object.keys(enabledSub).forEach(key => {
          if (!dimensionKeySet.has(key)) {
            enabledSub[key] = false;
          }
        });
        const explicitGroupKeys = new Set(Object.keys(snapshot.enabled || {}));
        groupKeys.forEach(groupKey => {
          if (explicitGroupKeys.has(groupKey)) return;
          const subKeys = groupOptionMap[groupKey] || [];
          const hasVisibleSub = subKeys.some(subKey => dimensionKeySet.has(subKey));
          if (!hasVisibleSub) {
            enabled[groupKey] = false;
          }
        });
        if (snapshot.descriptions) {
          if (typeof snapshot.descriptions.en === 'string') descriptions.en = snapshot.descriptions.en;
          if (typeof snapshot.descriptions.zh === 'string') descriptions.zh = snapshot.descriptions.zh;
        }
        const nextDimensionSetKey = snapshot.dimensionSetKey || activeDimensionSetKey;
        if (nextDimensionSetKey) {
          setActiveDimensionSet(nextDimensionSetKey, { refresh: true });
        } else {
          rebuildDimensionGroups();
        }
        syncCustomData();
        syncDescriptionInputValue();
      }
      function pick(list, idx) {
        if (!Array.isArray(list) || list.length === 0) return '';
        const opt = list[idx] ?? list[0];
        if (!opt) return '';
        return opt.value || opt[current.lang] || opt.en || opt.zh || '';
      }
      function getState() {
        return {
          hairStyle: pick(options.hairStyle, state.hairStyle),
          hairAccessory: pick(options.hairAccessory, state.hairAccessory),
          hairColor: pick(options.hairColor, state.hairColor),
          top: pick(options.top, state.top),
          garmentMaterial: pick(options.garmentMaterial, state.garmentMaterial),
          garmentPattern: pick(options.garmentPattern, state.garmentPattern),
          garmentDetail: pick(options.garmentDetail, state.garmentDetail),
          obi: pick(options.obi, state.obi),
          nails: pick(options.nails, state.nails),
          earrings: pick(options.earrings, state.earrings),
          rings: pick(options.rings, state.rings),
          makeupStyle: pick(options.makeupStyle, state.makeupStyle),
          blush: pick(options.blush, state.blush),
          eyeliner: pick(options.eyeliner, state.eyeliner),
          eyelashes: pick(options.eyelashes, state.eyelashes),
          eyeDetail: pick(options.eyeDetail, state.eyeDetail),
          eyebrows: pick(options.eyebrows, state.eyebrows),
          contour: pick(options.contour, state.contour),
          lips: pick(options.lips, state.lips),
          hands: pick(options.hands, state.hands),
          shoulderPose: pick(options.shoulderPose, state.shoulderPose),
          expression: pick(options.expression, state.expression),
          posture: pick(options.posture, state.posture),
          cameraAngle: pick(options.cameraAngle, state.cameraAngle),
          cameraType: pick(options.cameraType, state.cameraType),
          frame: pick(options.frame, state.frame),
          aspectRatio: pick(options.aspectRatio, state.aspectRatio),
          backgroundType: pick(options.backgroundType, state.backgroundType),
          bgColor: pick(options.bgColor, state.bgColor),
          backgroundElements: pick(options.backgroundElements, state.backgroundElements),
          bgEffect: pick(options.bgEffect, state.bgEffect),
          lighting: pick(options.lighting, state.lighting),
          mood: pick(options.mood, state.mood),
          genre: pick(options.genre, state.genre),
          aesthetic: pick(options.aesthetic, state.aesthetic),
          quality: pick(options.quality, state.quality),
          skinTexture: pick(options.skinTexture, state.skinTexture),
          skinTone: pick(options.skinTone, state.skinTone),
          skinHighlight: pick(options.skinHighlight, state.skinHighlight),
          renderStyle: pick(options.renderStyle, state.renderStyle),
          ageShift: pick(options.ageShift, state.ageShift),
          description: descriptions[current.lang],
          lightingCondition: defaults.camera?.lighting_condition || ''
        };
      }
      function composeJsonObject(s) {
        const obj = { description: s.description };
        const groupActive = (key) => enabled[key] && isGroupVisibleNow(key);
        const dimActive = (key) => enabledSub[key] && !lockedSub[key] && isDimensionVisibleNow(key);
        if (groupActive('hairStyle') || groupActive('hairColor')) {
          const hair = {};
          if (groupActive('hairStyle') && dimActive('hairStyle')) hair.style = s.hairStyle;
          if (groupActive('hairStyle') && dimActive('hairAccessory')) hair.accessories = s.hairAccessory;
          if (groupActive('hairColor') && dimActive('hairColor')) hair.color = s.hairColor;
          if (Object.keys(hair).length) obj.hair = hair;
        }
        if (groupActive('clothing')) {
          const clothing = {};
          if (dimActive('top')) clothing.top = s.top;
          if (dimActive('garmentMaterial')) clothing.material = s.garmentMaterial;
          if (dimActive('garmentPattern')) clothing.pattern = s.garmentPattern;
          if (dimActive('garmentDetail')) clothing.details = s.garmentDetail;
          if (dimActive('obi')) clothing.obi = s.obi;
          if (dimActive('nails')) clothing.nails = s.nails;
          const accessories = {};
          if (dimActive('earrings')) accessories.earrings = s.earrings;
          if (dimActive('rings')) accessories.rings = s.rings;
          if (Object.keys(accessories).length) clothing.accessories = accessories;
          if (Object.keys(clothing).length) obj.clothing = clothing;
        }
        if (groupActive('makeup')) {
          const makeup = {};
          if (dimActive('makeupStyle')) makeup.style = s.makeupStyle;
          const details = {};
          if (dimActive('eyebrows')) details.eyebrows = s.eyebrows;
          if (dimActive('eyeliner')) details.eyeliner = s.eyeliner;
          if (dimActive('eyelashes')) details.eyelashes = s.eyelashes;
          if (dimActive('eyeDetail')) details.eyes = s.eyeDetail;
          if (dimActive('blush')) details.blush = s.blush;
          if (dimActive('contour')) details.contour = s.contour;
          if (dimActive('lips')) details.lips = s.lips;
          if (Object.keys(details).length) makeup.details = details;
          if (Object.keys(makeup).length) obj.makeup = makeup;
        }
        if (groupActive('pose')) {
          const pose = {};
          if (dimActive('hands')) pose.hands = s.hands;
          if (dimActive('shoulderPose')) pose.shoulder = s.shoulderPose;
          if (dimActive('expression')) pose.expression = s.expression;
          if (dimActive('posture')) pose.posture = s.posture;
          if (dimActive('cameraAngle')) pose.camera_angle = s.cameraAngle;
          if (Object.keys(pose).length) obj.pose = pose;
        }
        if (groupActive('composition')) {
          const composition = {};
          if (dimActive('frame')) composition.frame = s.frame;
          if (dimActive('aspectRatio')) composition.aspect_ratio = s.aspectRatio;
          if (Object.keys(composition).length) obj.composition = composition;
        }
        if (groupActive('background')) {
          const background = {};
          if (dimActive('backgroundType')) background.type = s.backgroundType;
          if (dimActive('bgColor')) background.color = s.bgColor;
          if (dimActive('backgroundElements')) background.elements = s.backgroundElements;
          if (dimActive('bgEffect')) background.effect = s.bgEffect;
          if (dimActive('lighting')) background.lighting = s.lighting;
          if (Object.keys(background).length) obj.background = background;
        }
        if (groupActive('style')) {
          const style = {};
          if (dimActive('genre')) style.genre = s.genre;
          if (dimActive('mood')) style.mood = s.mood;
          if (dimActive('aesthetic')) style.aesthetic = s.aesthetic;
          if (Object.keys(style).length) obj.style = style;
        }
        if (groupActive('detail')) {
          const detail = {};
          if (dimActive('quality')) detail.quality = s.quality;
          if (dimActive('skinTexture')) detail.skin_texture = s.skinTexture;
          if (dimActive('skinTone')) detail.skin_tone = s.skinTone;
          if (dimActive('skinHighlight')) detail.highlights = s.skinHighlight;
          if (dimActive('renderStyle')) detail.render = s.renderStyle;
          if (dimActive('ageShift')) detail.age_adjustment = s.ageShift;
          if (Object.keys(detail).length) obj.detail = detail;
        }
        if (groupActive('camera')) {
          const camera = {};
          if (dimActive('cameraType')) camera.type = s.cameraType;
          if (Object.keys(camera).length) obj.camera = camera;
        }
        if (customDimensions.length) {
          obj.custom_dimensions = customDimensions.map(dim => {
            const entries = options[dim.key] || [];
            const sel = entries[state[dim.key]] || entries[0] || {};
            const valueZh = sel.zh || '';
            const valueEn = sel.en || sel.zh || '';
            return {
              key: dim.key,
              name_zh: dim.name.zh,
              name_en: dim.name.en || dim.name.zh,
              value_zh: valueZh,
              value_en: valueEn
            };
          });
        }
        return obj;
      }
      function composeAndRender() {
        const s = getState();
        const obj = composeJsonObject(s);
        if (els.promptOutput) {
          els.promptOutput.textContent = JSON.stringify(obj, null, 2);
        }
        maybeResetActivePreset();
        persistCurrentState();
      }
      function persistCurrentState() {
        const snapshot = {
          state,
          enabled,
          enabledSub,
          locked,
          lockedSub,
          customDimensions,
          savedConfigs,
          activeSavedConfigId,
          uiMode,
          currentLang: current.lang,
          dimensionSetKey: activeDimensionSetKey,
          descriptions: { ...descriptions }
        };
        saveToStorage(snapshot);
      }
      let chipPopover = null;
      let chipPopoverOutsideHandler = null;
      function openChipPopover(target, key) {
        closeChipPopover();
        const menu = document.createElement('div');
        menu.className = 'popover';
        const ul = document.createElement('ul');
        const list = options[key] || [];
        list.forEach((opt, idx) => {
          const li = document.createElement('li');
          li.textContent = opt[current.lang] || opt.en || opt.zh || '';
          li.addEventListener('click', () => {
            state[key] = idx;
            composeAndRender();
            init();
            closeChipPopover();
          });
          ul.appendChild(li);
        });
        menu.appendChild(ul);
        document.body.appendChild(menu);
        const rect = target.getBoundingClientRect();
        menu.style.top = `${rect.bottom + window.scrollY + 8}px`;
        menu.style.left = `${rect.left + window.scrollX}px`;
        chipPopover = menu;
        chipPopoverOutsideHandler = (e) => {
          const isClickInsidePopover = chipPopover && chipPopover.contains(e.target);
          const isTrigger = target.contains(e.target);
          if (!isClickInsidePopover && !isTrigger) {
            closeChipPopover();
          }
        };
        setTimeout(() => { document.addEventListener('click', chipPopoverOutsideHandler); }, 0);
      }
      function closeChipPopover() {
        if (chipPopover) {
          chipPopover.remove();
          chipPopover = null;
        }
        if (chipPopoverOutsideHandler) {
          document.removeEventListener('click', chipPopoverOutsideHandler);
          chipPopoverOutsideHandler = null;
        }
      }
      async function copyTextToClipboard(text) {
        if (!navigator?.clipboard) {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            return true;
          } catch (err) {
            return false;
          } finally {
            textarea.remove();
          }
        }
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (err) {
          return false;
        }
      }
      function showCopyFeedback() {
        if (!els.copyPrompt) return;
        els.copyPrompt.classList.remove('copy-error');
        els.copyPrompt.classList.add('copied');
        updateCopyLabel();
        clearTimeout(copyFeedbackTimer);
        copyFeedbackTimer = setTimeout(() => {
          els.copyPrompt.classList.remove('copied');
          updateCopyLabel();
        }, 1600);
      }
      function showCopyError() {
        if (!els.copyPrompt) return;
        els.copyPrompt.classList.remove('copied');
        els.copyPrompt.classList.add('copy-error');
        updateCopyLabel();
        clearTimeout(copyFeedbackTimer);
        copyFeedbackTimer = setTimeout(() => {
          els.copyPrompt.classList.remove('copy-error');
          updateCopyLabel();
        }, 1600);
      }
      function captureCurrentSnapshot() {
        const visibleKeys = getVisibleDimensionKeys();
        const customKeys = customDimensions.map(dim => dim.key).filter(Boolean);
        const dimensionKeySet = new Set([...visibleKeys, ...customKeys]);
        return {
          state: { ...state },
          enabled: { ...enabled },
          enabledSub: { ...enabledSub },
          locked: { ...locked },
          lockedSub: { ...lockedSub },
          dimensionSetKey: activeDimensionSetKey,
          descriptions: { ...descriptions },
          dimensionKeys: Array.from(dimensionKeySet)
        };
      }
      function shallowEqualMap(a = {}, b = {}) {
        const keys = new Set([...(Object.keys(a || {})), ...(Object.keys(b || {}))]);
        for (const key of keys) {
          if ((a || {})[key] !== (b || {})[key]) return false;
        }
        return true;
      }
      function snapshotsEqual(a, b) {
        if (!a || !b) return false;
        return a.dimensionSetKey === b.dimensionSetKey
          && shallowEqualMap(a.state, b.state)
          && shallowEqualMap(a.enabled, b.enabled)
          && shallowEqualMap(a.enabledSub, b.enabledSub)
          && shallowEqualMap(a.locked, b.locked)
          && shallowEqualMap(a.lockedSub, b.lockedSub)
          && shallowEqualMap(a.descriptions, b.descriptions);
      }
      function maybeResetActivePreset() {
        if (!activeSavedConfigId) return;
        const preset = savedConfigs.find(cfg => cfg.id === activeSavedConfigId);
        if (!preset) {
          activeSavedConfigId = null;
          renderPresetSidebar();
          return;
        }
        const currentSnapshot = captureCurrentSnapshot();
        if (!snapshotsEqual(currentSnapshot, preset.snapshot)) {
          activeSavedConfigId = null;
          renderPresetSidebar();
      }
      }
      function handleSavePreset() {
        if (!els.presetModalInput) return;
        const rawName = els.presetModalInput.value.trim();
        if (!rawName) {
          window.alert(uiText.savedErrorName[current.lang]);
          els.presetModalInput.focus();
          return;
        }
        let targetIdx = editingPresetId ? savedConfigs.findIndex(cfg => cfg.id === editingPresetId) : -1;
        if (targetIdx < 0) targetIdx = savedConfigs.findIndex(cfg => cfg.name === rawName);
        const existing = targetIdx >= 0 ? savedConfigs[targetIdx] : null;
        const tags = normalizeTagList(els.presetTagsInput?.value || '');
        const thumbnail = (els.presetThumbnailInput?.value || '').trim();
        const payload = {
          id: existing?.id || createPresetId(),
          name: rawName,
          snapshot: captureCurrentSnapshot(),
          tags,
          thumbnail,
          favorite: existing?.favorite || false,
          updatedAt: Date.now()
        };
        if (targetIdx >= 0) savedConfigs.splice(targetIdx, 1);
        savedConfigs.unshift(payload);
        activeSavedConfigId = payload.id;
        closeSaveModal();
        renderPresetSidebar();
        persistCurrentState();
      }
      function deleteSavedConfig(id) {
        const idx = savedConfigs.findIndex(cfg => cfg.id === id);
        if (idx < 0) return false;
        const confirmMsg = uiText.savedDeleteConfirm[current.lang];
        if (confirmMsg && !window.confirm(confirmMsg)) return false;
        const [removed] = savedConfigs.splice(idx, 1);
        if (removed && removed.id === activeSavedConfigId) activeSavedConfigId = null;
        renderPresetSidebar();
        persistCurrentState();
        return true;
      }
      function loadSavedConfig(id) {
        const preset = savedConfigs.find(cfg => cfg.id === id);
        if (!preset) return;
        applyPresetSnapshot(preset.snapshot);
        activeSavedConfigId = id;
        init();
        composeAndRender();
      }

      function updateModeToggleLabel() {
        if (!els.modeToggle) return;
        els.modeToggle.textContent = uiMode === 'dropdown' ? uiText.modeDropdown[current.lang] : uiText.modeExpanded[current.lang];
      }

      function updateCustomFormLabels() {
        if (els.customAddTrigger) els.customAddTrigger.textContent = uiText.customAddTrigger[current.lang];
        if (els.customNameZh) els.customNameZh.placeholder = uiText.customNameZhPlaceholder[current.lang];
        if (els.customNameEn) els.customNameEn.placeholder = uiText.customNameEnPlaceholder[current.lang];
        if (els.customOptionsInput) els.customOptionsInput.placeholder = uiText.customOptionsPlaceholder[current.lang];
        if (els.customOptionsHint) els.customOptionsHint.textContent = uiText.customHint[current.lang];
        if (els.customSaveBtn) els.customSaveBtn.textContent = editingCustomId ? uiText.customSaveEdit[current.lang] : uiText.customSave[current.lang];
        if (els.customModalTitle) {
          const titleKey = editingCustomId ? 'customModalEditTitle' : 'customModalAddTitle';
          els.customModalTitle.textContent = uiText[titleKey][current.lang];
        }
        if (els.customModalClose) {
          const label = uiText.customModalClose[current.lang];
          els.customModalClose.setAttribute('aria-label', label);
          els.customModalClose.title = label;
        }
        if (els.customCancelBtn) els.customCancelBtn.textContent = uiText.customCancel[current.lang];
      }

      function applyLabels() {
        document.querySelectorAll('.group-title').forEach(el => {
          const key = el.dataset.group;
          if (!key) return;
          const label = uiLabels.groups[key]?.[current.lang];
          if (label) el.textContent = label;
        });
        document.querySelectorAll('.sub-title').forEach(el => {
          const key = el.dataset.sub;
          if (!key) return;
          const label = uiLabels.subs[key]?.[current.lang];
          if (label) el.textContent = label;
        });
        if (els.appTitle) els.appTitle.textContent = uiText.title[current.lang];
        if (els.dimensionHeading) els.dimensionHeading.textContent = uiText.dimensionHeading[current.lang];
        if (els.descriptionLabel) els.descriptionLabel.textContent = uiText.descriptionLabel[current.lang];
        if (els.descriptionHint) els.descriptionHint.textContent = uiText.descriptionHint[current.lang];
        if (els.descriptionInput) els.descriptionInput.placeholder = uiText.descriptionPlaceholder[current.lang];
        if (els.outputHeading) els.outputHeading.textContent = uiText.outputHeading[current.lang];
        if (els.randomLabel) els.randomLabel.textContent = uiText.random[current.lang];
        if (els.copyLabel) {
          updateCopyLabel();
        }
        if (els.saveLabel) els.saveLabel.textContent = uiText.savedPanelToggle[current.lang];
        if (els.presetSidebarTitleText) els.presetSidebarTitleText.textContent = uiText.presetSidebarTitle[current.lang];
        if (els.presetSearchInput) els.presetSearchInput.placeholder = uiText.presetSearchPlaceholder[current.lang];
        if (els.presetModalTitle) els.presetModalTitle.textContent = uiText.savedModalTitle[current.lang];
        if (els.presetModalInput) els.presetModalInput.placeholder = uiText.savedModalPlaceholder[current.lang];
        if (els.presetTagsInput) els.presetTagsInput.placeholder = uiText.presetTagsPlaceholder[current.lang];
        if (els.presetThumbnailInput) els.presetThumbnailInput.placeholder = uiText.presetThumbnailPlaceholder[current.lang];
        if (els.thumbnailDropHint) els.thumbnailDropHint.textContent = uiText.presetThumbnailDropHint[current.lang];
        setThumbnailDropStatus(thumbnailDropStatusKey);
        if (els.presetModalSave) els.presetModalSave.textContent = uiText.savedModalSave[current.lang];
        if (els.presetModalCancel) els.presetModalCancel.textContent = uiText.savedModalCancel[current.lang];
        if (els.presetModalDelete) els.presetModalDelete.textContent = uiText.presetDelete[current.lang];
        renderDimensionSetSelect();
        updateModeToggleLabel();
        updateCustomFormLabels();
        syncDescriptionInputValue();
      }

      function updateLangStrings() {
        applyLabels();
      }

      function findIdx(list, matchValue) {
        if (!Array.isArray(list) || list.length === 0) return 0;
        if (!matchValue) return 0;
        const byValue = list.findIndex(v => v.value === matchValue);
        if (byValue >= 0) return byValue;
        return Math.max(0, list.findIndex(v => v.en === matchValue));
      }
      const state = {};
      Object.keys(options).forEach(key => {
        const list = Array.isArray(options[key]) ? options[key] : [];
        const maxIdx = Math.max(0, list.length - 1);
        const defaultIdx = Number.isFinite(dimensionDefaults[key]) ? dimensionDefaults[key] : 0;
        state[key] = Math.max(0, Math.min(maxIdx, defaultIdx));
      });

      const defaultState = { ...state };
      if (savedData?.state) Object.assign(state, savedData.state);
      const enabled = {};
      const locked = {};
      groupKeys.forEach(key => {
        const meta = groupsMeta.find(g => g.key === key) || {};
        enabled[key] = meta.defaultEnabled !== false;
        locked[key] = !!meta.defaultLocked;
      });
      const defaultEnabled = { ...enabled };
      const defaultLocked = { ...locked };
      if (savedData?.enabled) Object.assign(enabled, savedData.enabled);
      if (savedData?.locked) Object.assign(locked, savedData.locked);
      const enabledSub = {};
      const lockedSub = {};
      Object.keys(options).forEach(key => {
        enabledSub[key] = true;
        lockedSub[key] = false;
      });
      const defaultEnabledSub = { ...enabledSub };
      const defaultLockedSub = { ...lockedSub };
      if (savedData?.enabledSub) Object.assign(enabledSub, savedData.enabledSub);
      if (savedData?.lockedSub) Object.assign(lockedSub, savedData.lockedSub);
      function setLockButtonState(btn, isLocked) {
        if (!btn) return;
        btn.classList.toggle('locked', !!isLocked);
        btn.innerHTML = isLocked ? lockIcons.locked : lockIcons.unlocked;
        btn.setAttribute('aria-pressed', String(!!isLocked));
      }
      function createPresetSnapshotFromOverrides(overrides = {}) {
        const snapshotState = { ...defaultState };
        const stateOverrides = overrides.state || {};
        const filteredStateKeys = Object.keys(stateOverrides).filter(key => key in snapshotState);
        const manualDimensionKeys = Array.isArray(overrides.dimensionKeys)
          ? overrides.dimensionKeys.filter(key => typeof key === 'string' && key in snapshotState)
          : null;
        Object.entries(stateOverrides).forEach(([key, label]) => {
          if (!(key in snapshotState)) return;
          const list = options[key];
          if (!list) return;
          const idx = findIdx(list, label);
          if (idx >= 0) snapshotState[key] = idx;
        });
        const snapshotDescriptions = { ...descriptions };
        if (overrides.description) {
          const desc = overrides.description;
          if (typeof desc.en === 'string') snapshotDescriptions.en = desc.en;
          if (typeof desc.zh === 'string') snapshotDescriptions.zh = desc.zh;
        }
        const snapshotDimensionKeys = (manualDimensionKeys && manualDimensionKeys.length ? manualDimensionKeys : filteredStateKeys)
          .filter(key => options[key]);
        return {
          state: snapshotState,
          enabled: { ...defaultEnabled, ...(overrides.enabled || {}) },
          enabledSub: { ...defaultEnabledSub, ...(overrides.enabledSub || {}) },
          locked: { ...defaultLocked, ...(overrides.locked || {}) },
          lockedSub: { ...defaultLockedSub, ...(overrides.lockedSub || {}) },
          descriptions: snapshotDescriptions,
          dimensionSetKey: overrides.dimensionSetKey || activeDimensionSetKey,
          dimensionKeys: snapshotDimensionKeys.length
            ? snapshotDimensionKeys
            : getDimensionKeysForSetKey(overrides.dimensionSetKey || activeDimensionSetKey)
        };
      }
      const builtinPresetDefinitions = Array.isArray(promptConfig.presets) ? promptConfig.presets : [];
      const builtinPresetMap = builtinPresetDefinitions.reduce((acc, def) => {
        if (def && def.id) acc[def.id] = def;
        return acc;
      }, {});

      function ensureBuiltinPresets() {
        if (!Array.isArray(savedConfigs)) savedConfigs = [];
        const existing = new Set(savedConfigs.map(cfg => cfg.id));
        const nameSet = new Set(savedConfigs.map(cfg => cfg.name));
        const inserts = [];
        builtinPresetDefinitions.forEach(def => {
          if (existing.has(def.id) || nameSet.has(def.name)) return;
          const snapshot = createPresetSnapshotFromOverrides({
            state: def.state,
            description: def.description,
            enabled: def.enabled,
            enabledSub: def.enabledSub,
            locked: def.locked,
            lockedSub: def.lockedSub,
            dimensionSetKey: def.dimensionSetKey,
            dimensionKeys: def.dimensionKeys
          });
          inserts.push({
            id: def.id,
            name: def.name,
            snapshot,
            tags: normalizeTagList(def.tags),
            thumbnail: typeof def.thumbnail === 'string' ? def.thumbnail : '',
            favorite: !!def.favorite,
            updatedAt: Date.now()
          });
        });
        if (inserts.length) {
          savedConfigs = [...inserts, ...savedConfigs];
        }
      }
      ensureBuiltinPresets();
      function deriveDimensionKeysFromPreset(def) {
        if (!def) return [];
        if (Array.isArray(def.dimensionKeys) && def.dimensionKeys.length) {
          return def.dimensionKeys.filter(key => options[key]);
        }
        const stateKeys = def.state && typeof def.state === 'object' ? Object.keys(def.state) : [];
        if (stateKeys.length) return stateKeys.filter(key => options[key]);
        return getDimensionKeysForSetKey(def.dimensionSetKey);
      }
      function ensureSnapshotDimensionKeys(cfg) {
        if (!cfg || !cfg.snapshot) return;
        if (Array.isArray(cfg.snapshot.dimensionKeys) && cfg.snapshot.dimensionKeys.length) {
          cfg.snapshot.dimensionKeys = cfg.snapshot.dimensionKeys.filter(key => options[key]);
          return;
        }
        const builtinDef = cfg.id ? builtinPresetMap[cfg.id] : null;
        let keys = builtinDef ? deriveDimensionKeysFromPreset(builtinDef) : [];
        if (!keys.length) {
          keys = getDimensionKeysForSetKey(cfg.snapshot.dimensionSetKey);
        }
        cfg.snapshot.dimensionKeys = keys;
      }
      function ensureSavedConfigsDimensionKeys() {
        if (!Array.isArray(savedConfigs)) return;
        savedConfigs.forEach(cfg => ensureSnapshotDimensionKeys(cfg));
      }
      ensureSavedConfigsDimensionKeys();
      function refreshOptionsForKey(key) {
        const container = els[key] || document.getElementById(key);
        if (!container || !options[key]) return;
        renderOptions(container, options[key], state[key], key);
      }
      function syncGroupLockFromSubs(groupKey) {
        if (!(groupKey in locked)) return;
        const subKeys = groupOptionMap[groupKey] || [];
        if (!subKeys.length) return;
        const allLocked = subKeys.every(subKey => lockedSub[subKey]);
        if (locked[groupKey] !== allLocked) {
          locked[groupKey] = allLocked;
          const groupBtn = document.querySelector(`.lock-btn[data-group="${groupKey}"]`);
          setLockButtonState(groupBtn, allLocked);
          const wrap = groupWraps[groupKey];
          if (wrap) wrap.classList.toggle('group-locked', allLocked);
        }
      }
      function applySubLockState(subKey, isLocked, opts = {}) {
        if (!(subKey in lockedSub)) return;
        lockedSub[subKey] = !!isLocked;
        const subBtn = document.querySelector(`.lock-btn[data-sub="${subKey}"]`);
        setLockButtonState(subBtn, lockedSub[subKey]);
        refreshOptionsForKey(subKey);
        setSubStateByKey(subKey);
        const parentGroup = subToGroupMap[subKey];
        if (!opts.skipSync && parentGroup) syncGroupLockFromSubs(parentGroup);
        if (!opts.skipPersist) persistCurrentState();
      }
      function applyGroupLockState(groupKey, isLocked, opts = {}) {
        if (!(groupKey in locked)) return;
        locked[groupKey] = !!isLocked;
        const groupBtn = document.querySelector(`.lock-btn[data-group="${groupKey}"]`);
        setLockButtonState(groupBtn, locked[groupKey]);
        const wrap = groupWraps[groupKey];
        if (wrap) wrap.classList.toggle('group-locked', locked[groupKey]);
        const subKeys = groupOptionMap[groupKey] || [];
        subKeys.forEach(subKey => {
          applySubLockState(subKey, locked[groupKey], { skipPersist: true, skipSync: true });
        });
        syncGroupLockFromSubs(groupKey);
        if (!opts.skipPersist) persistCurrentState();
      }
      function setSubStateByKey(subKey) {
        if (!subKey) return;
        const isEnabled = enabledSub[subKey] !== false;
        const isLocked = !!lockedSub[subKey];
        const titleEl = document.querySelector(`.sub-title[data-sub="${subKey}"]`);
        const row = titleEl ? titleEl.closest('.sub-title-row') : null;
        if (row) {
          row.classList.toggle('sub-disabled', !isEnabled);
          row.classList.toggle('sub-locked', isLocked);
        }
        const wrap = document.getElementById(subKey);
        if (wrap) {
          wrap.classList.toggle('sub-disabled', !isEnabled);
          wrap.classList.toggle('sub-locked', isLocked);
          wrap.querySelectorAll('.option').forEach(btn => btn.classList.toggle('disabled', !isEnabled || isLocked));
        }
        const visBtn = document.querySelector(`.visibility-btn[data-sub="${subKey}"]`);
        setVisibilityButtonState(visBtn, isEnabled);
      }
      const collapsedGroups = {};
      const collapsedSub = {};
      const optionListenerElements = new WeakSet();
      function bindOptionContainer(el, key) {
        if (!el || optionListenerElements.has(el)) return;
        el.addEventListener('click', e => {
          const t = e.target;
          if (!t.classList.contains('option')) return;
          if (uiMode !== 'expanded') return;
          if (!enabledSub[key] || lockedSub[key]) return;
          const v = Number(t.dataset.idx);
          state[key] = v;
          el.querySelectorAll('.option').forEach(btn => btn.classList.remove('active'));
          t.classList.add('active');
          composeAndRender();
        });
        optionListenerElements.add(el);
      }
      function parseCustomOptionsText(text) {
        return (text || '').split('\n').map(line => line.trim()).filter(Boolean).map(line => {
          const parts = line.split('|').map(v => v.trim()).filter(Boolean);
          const zh = parts[0] || '';
          const en = parts[1] || zh;
          return { zh, en };
        });
      }
      function createPresetId() {
        return `preset_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
      }
      function cloneSnapshotSection(value) {
        return value && typeof value === 'object' ? { ...value } : {};
      }
      function normalizeTagList(value) {
        if (Array.isArray(value)) {
          return value.map(v => (typeof v === 'string' ? v.trim() : '')).filter(Boolean);
        }
        if (typeof value === 'string') {
          return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
      }
      function normalizeSavedConfigs(list) {
        if (!Array.isArray(list)) return [];
        return list.map(entry => {
          if (!entry || typeof entry !== 'object') return null;
          const name = (entry.name || '').trim();
          if (!name) return null;
          const snapshot = entry.snapshot && typeof entry.snapshot === 'object' ? entry.snapshot : {};
          return {
            id: entry.id || createPresetId(),
            name,
            snapshot: {
              state: cloneSnapshotSection(snapshot.state),
              enabled: cloneSnapshotSection(snapshot.enabled),
              enabledSub: cloneSnapshotSection(snapshot.enabledSub),
              locked: cloneSnapshotSection(snapshot.locked),
              lockedSub: cloneSnapshotSection(snapshot.lockedSub),
              descriptions: cloneSnapshotSection(snapshot.descriptions),
              dimensionSetKey: snapshot.dimensionSetKey || activeDimensionSetKey,
              dimensionKeys: Array.isArray(snapshot.dimensionKeys)
                ? snapshot.dimensionKeys.filter(key => typeof key === 'string' && options[key])
                : undefined
            },
            tags: normalizeTagList(entry.tags),
            thumbnail: typeof entry.thumbnail === 'string' ? entry.thumbnail : '',
            favorite: !!entry.favorite,
            updatedAt: typeof entry.updatedAt === 'number' ? entry.updatedAt : Date.now()
          };
        }).filter(Boolean);
      }
      function syncCustomData() {
        customDimensions = (customDimensions || []).map(dim => {
          const id = dim.id || String(Date.now() + Math.random());
          const key = dim.key || `custom_${id}`;
          const name = dim.name || {};
          const zhName = name.zh || dim.labelZh || '';
          const enName = name.en || dim.labelEn || zhName;
          const optionArray = Array.isArray(dim.options) ? dim.options : [];
          const rawTextFallback = optionArray.map(opt => {
            if (!opt) return '';
            const zh = opt.zh || '';
            const en = opt.en && opt.en !== zh ? ` | ${opt.en}` : '';
            return `${zh}${en}`;
          }).filter(Boolean).join('\n');
          const rawText = dim.rawText ?? dim.optionsText ?? rawTextFallback;
          const optionsList = parseCustomOptionsText(rawText);
          return { id, key, name: { zh: zhName, en: enName }, rawText, options: optionsList };
        });
        customDimensions.forEach(dim => {
          options[dim.key] = dim.options;
          if (!(dim.key in state)) state[dim.key] = 0;
          if (!(dim.key in enabledSub)) enabledSub[dim.key] = true;
          if (!(dim.key in lockedSub)) lockedSub[dim.key] = false;
        });
        Object.keys(state).forEach(key => {
          if (key.startsWith('custom_') && !customDimensions.some(dim => dim.key === key)) {
            delete state[key];
          }
        });
        Object.keys(enabledSub).forEach(key => {
          if (key.startsWith('custom_') && !customDimensions.some(dim => dim.key === key)) delete enabledSub[key];
        });
        Object.keys(lockedSub).forEach(key => {
          if (key.startsWith('custom_') && !customDimensions.some(dim => dim.key === key)) delete lockedSub[key];
        });
        Object.keys(options).forEach(key => {
          if (key.startsWith('custom_') && !customDimensions.some(dim => dim.key === key)) {
            delete options[key];
          }
        });
      }
      syncCustomData();
      function init() {
        const keys = getVisibleDimensionKeys();
        keys.forEach(key => {
          const container = els[key];
          if (container && options[key]) {
            renderOptions(container, options[key], state[key], key);
          }
        });
        renderCustomDimensions();
        updateLangStrings();
        renderPresetSidebar();
      }

      function bindClicks() {
        els.descriptionInput?.addEventListener('input', () => {
          descriptions[current.lang] = els.descriptionInput.value;
          composeAndRender();
        });
        els.langZh.addEventListener('click', () => { current.lang = 'zh'; updateLangClass(); els.langZh.classList.add('active'); els.langEn.classList.remove('active'); init(); composeAndRender(); });
        els.langEn.addEventListener('click', () => { current.lang = 'en'; updateLangClass(); els.langEn.classList.add('active'); els.langZh.classList.remove('active'); init(); composeAndRender(); });
        els.savedPanelToggle?.addEventListener('click', (e) => {
          e.preventDefault();
          openSaveModal();
        });
        els.modeToggle.addEventListener('click', () => {
          uiMode = uiMode === 'dropdown' ? 'expanded' : 'dropdown';
          updateModeToggleLabel();
          init();
          composeAndRender();
        });
      }
      function randomAllVisible() {
        const activeSet = getActiveDimensionSet();
        if (!activeSet) return;
        activeSet.groupOrder.forEach(groupKey => {
          if (!enabled[groupKey] || locked[groupKey]) return;
          (activeSet.dimensionsByGroup[groupKey] || []).forEach(dimKey => {
            if (!enabledSub[dimKey] || lockedSub[dimKey]) return;
            if (!visibleDimensions.has(dimKey)) return;
            const list = options[dimKey];
            if (!Array.isArray(list) || !list.length) return;
            const idx = Math.floor(Math.random() * list.length);
            state[dimKey] = idx;
          });
        });
        init();
        composeAndRender();
      }
      els.randomAll.addEventListener('click', randomAllVisible);
      els.copyPrompt.addEventListener('click', async () => {
        const t = (els.promptOutput.textContent || '').trim();
        if (!t) return;
        const success = await copyTextToClipboard(t);
        if (success) {
          showCopyFeedback();
        } else {
          showCopyError();
        }
      });
      els.presetModalSave?.addEventListener('click', e => { e.preventDefault(); handleSavePreset(); });
      els.presetModalCancel?.addEventListener('click', e => { e.preventDefault(); closeSaveModal(); });
      els.presetModalDelete?.addEventListener('click', e => {
        e.preventDefault();
        if (!editingPresetId) return;
        const targetId = editingPresetId;
        const deleted = deleteSavedConfig(targetId);
        if (deleted) closeSaveModal();
      });
      els.presetModalOverlay?.addEventListener('click', e => {
        if (e.target === els.presetModalOverlay) closeSaveModal();
      });
      els.presetModalInput?.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSavePreset();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          closeSaveModal();
        }
      });
      els.customSaveBtn?.addEventListener('click', e => { e.preventDefault(); handleCustomSave(); });
      els.customCancelBtn?.addEventListener('click', e => { e.preventDefault(); closeCustomModal(); });
      els.customAddTrigger?.addEventListener('click', e => { e.preventDefault(); resetCustomForm(); openCustomModal(); });
      els.customModalClose?.addEventListener('click', e => { e.preventDefault(); closeCustomModal(); });
      els.presetSearchInput?.addEventListener('input', e => handlePresetSearchInput(e.target.value));
      els.presetTagFilter?.addEventListener('click', e => {
        const btn = e.target.closest('.preset-tag-chip');
        if (!btn) return;
        togglePresetTag(btn.dataset.tag);
      });
      els.customModalOverlay?.addEventListener('click', e => {
        if (e.target === els.customModalOverlay) closeCustomModal();
      });
      els.dimensionSetSelect?.addEventListener('change', e => {
        const changed = setActiveDimensionSet(e.target.value);
        if (changed) {
          init();
          composeAndRender();
          persistCurrentState();
        }
      });

      rebuildDimensionGroups();
      init();
      bindClicks();
      composeAndRender();
</script>
  </body>
</html>
